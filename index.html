<!DOCTYPE HTML>
<html lang="en" >
    
    <head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <title>Introduction | Unmethods</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Build Status">
        <meta name="generator" content="GitBook 2.3.2">
        
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    <link rel="stylesheet" href="gitbook/style.css">
    
    

        
    
    
    <link rel="next" href="./docs/iterator.html" />
    
    

        
    </head>
    <body>
        
        
    <div class="book" data-level="0" data-basepath="." data-revision="Wed Sep 09 2015 18:07:11 GMT-0400 (EDT)">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
        

        

        
    
        <li class="chapter active" data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                
                        <i class="fa fa-check"></i>
                        
                        Introduction
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="docs/iterator.html">
            
                
                    <a href="./docs/iterator.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        Iterator
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="docs/keyed.html">
            
                
                    <a href="./docs/keyed.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        Keyed
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="docs/relation.html">
            
                
                    <a href="./docs/relation.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        Relation
                    </a>
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                Published with GitBook
            </a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Table of Contents"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Font Settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Share"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">
                    Share on Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    Share on Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    Share on Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    Share on Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    Share on Instapaper
                </button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Google"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Twitter"><i class="fa fa-twitter"></i></a>
    
    
    


    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >Unmethods</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="unmethods">Unmethods</h1>
<p><a href="https://travis-ci.org/modernserf/unmethods" target="_blank"><img src="https://travis-ci.org/modernserf/unmethods.svg" alt="Build Status"></a></p>
<p>Unmethods: useful JavaScript functions designed for modern types and syntax.</p>
<pre><code>import { map, take, into } from &quot;unmethods&quot;;
const results = aHugeList::map((x) =&gt; x.toUpperCase())::take(5)::into(Array);
</code></pre><h2 id="protocols">Protocols</h2>
<p>Like underscore, unmethods provides functions for working with arrays and objects. Unlike underscore, which operates on arrays and objects, unmethods operate on protocols, like the ES6 iterator protocol (for lazy collections) and the experimental keyed protocol (for key-value stores). This means that the same set of functions operate on all kinds of collections, such as ES6&apos;s Map and Set; new collection types need to only implement the basic protocol to use all of the unmethods. </p>
<h2 id="uniform-function-call-syntax">Uniform Function Call Syntax</h2>
<p>Most of the functions provided here can be called in three different ways:</p>
<pre><code class="lang-js"><span class="hljs-comment">// traditional</span>
<span class="hljs-keyword">const</span> a = map(list,fn);
<span class="hljs-comment">// curried</span>
<span class="hljs-keyword">const</span> b = map(fn)(list);
<span class="hljs-comment">// bound</span>
<span class="hljs-keyword">const</span> c = list::map(fn);
</code></pre>
<p>All thrree of these are identical.</p>
<h1 id="background">Background</h1>
<p>ES2015, the newest iteration of JavaScript, introduces a ton of new features, types, and syntactic sugar. Those have all been explored pretty thoroughly, but the one that has the greatest implications for JavaScript are iterators; not the construct in itself but the use of the Iterator protocol.</p>
<p>Iterators are made possible by two new features: <a href="http://www.2ality.com/2014/12/es6-symbols.html" target="_blank">symbols</a> and <a href="http://www.2ality.com/2015/03/es6-generators.html" target="_blank">generators</a>. Iterators are not necessarily a feature on their own, but rather a <em>set of conventions</em> around symbols and generators:</p>
<blockquote>
<p>Given that JavaScript does not have interfaces, Iterable is more of a convention:</p>
<p><strong>Source</strong>: A value is considered <em>iterable</em> if it has a method whose key is the symbol <code>Symbol.iterator</code> that returns a so-called <em>iterator</em>. The iterator is an object that returns values via its method <code>next()</code>. We say: it enumerates <em>items</em>, one per method call.</p>
<p><strong>Consumption</strong>: Data consumers use the iterator to retrieve the values they are consuming.
<a href="http://www.2ality.com/2015/02/es6-iteration.html" target="_blank">Iterables and iterators in ECMAScript 6</a></p>
</blockquote>
<p>Collections like Array and Map conform to the Source side of the convention, and syntax like for-of and the spread operator conform to the Consumption side of the convention.</p>
<p>But JavaScript is a language that favors patterns and conventions over high-level features -- after all, <code>class</code> syntax is appearing just now, after nearly 20 years of implementing classical models via constructor functions and prototypes. Given that the iterable pseudo-interface is supported at a syntactic level by <code>for-of</code> and the spread operator, it seems like this is a pattern worth investigating.</p>
<h1 id="methods">Methods</h1>
<blockquote>
<p>it is often said that the anti-pattern that damages OO programming the most is inheritance. Hot take: nope, its methods.
<a href="https://twitter.com/modernserf/status/619001200889999360" target="_blank">@modernserf</a></p>
</blockquote>
<p>Its hard to get people to agree on what makes a language object-oriented -- its usually some combination of inheritance, self-reference, message passing and late binding -- but somehow the majority of them have ended up with something resembling methods -- functions that have a <code>caller.method(argument)</code> format, in which the caller is passed as an extra argument. Ruby implements this in terms of message passing; Go (which is arguably <em>not</em> OO) implements it as special syntax on regular functions, and JavaScript does it via first-class functions and the magic <code>this</code> variable. </p>
<p>Method syntax is convenient because it effectively allows us to read chains of functions left to right -- <code>foo.bar().baz().quux()</code> is easier to parse (for english speakers, at least) than <code>quux(baz(bar(foo)))</code>. Methods, in this sense, are effectively infix operators.</p>
<p>But in order to get this nice syntax, there&apos;s a huge tradeoff -- a method must be attached to its caller. In JavaScript, this means that either <code>foo</code> or something on <code>foo</code>&apos;s prototype chain must have a <code>bar()</code> method. This is fine for your own objects, but what if you want to use a method on strings or arrays?</p>
<p>Enter <a href="http://perfectionkills.com/extending-native-builtins/" target="_blank">Monkey Patching</a>. If you want to use <code>bar()</code> with all arrays, just stick it on the Array prototype! Which works fine until someone else defines a <code>bar()</code> method that&apos;s incompatible with yours. Or, worse yet, the sandard library defines a <code>bar()</code> method that&apos;s similar to yours, except for a few maddening edge cases.</p>
<p>But the part that bugs me the most about methods in JS (and in OO languages in general) is that it conflates struct-field relationships (semantics) with subject-verb-object dataflow (syntax). Go shows that its not necessary to have self-reference to use method syntax (Go methods live side by side with the structs they interact with, they are not members of the struct) and the D language takes this further with <a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank">Uniform Function Call Syntax</a> -- <code>foo.bar(baz)</code> is mostly just a different syntax for <code>bar(foo,baz)</code>.</p>
<p>How can we use method syntax without actually using methods? </p>
<h1 id="bind-operator">Bind Operator</h1>
<p>ES2016 is experimenting with the <a href="http://blog.jeremyfairbank.com/javascript/javascript-es7-function-bind-syntax/" target="_blank">bind operator</a>, which allows you to call a function with <code>this</code> bound to the left-hand side of the operator. Effectively, it allows you use methods from one type on objects of another without going through the whole <code>Array.prototype.slice.call(arguments)</code> dance. </p>
<p>But it also allows you to use <em>free methods</em>, functions written in the method style (e.g. using <code>this</code> as an argument) that aren&apos;t attached to any type. Clever people soon realized that you can combine these new syntaxes to create a library of functions that operate on <em>any</em> iterator and support left-to-right bind syntax:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">map</span> (<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">yield</span> fn(item);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">take</span> (<span class="hljs-params">count</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">yield</span> item;
        count--;
        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) { <span class="hljs-keyword">break</span>; }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>);
}

[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;baz&quot;</span>]::map((x) =&gt; x.toUpperCase())::take(<span class="hljs-number">5</span>)::toArray();
<span class="hljs-comment">// =&gt; [&quot;FOO&quot;,&quot;BAR&quot;,&quot;BAZ&quot;]</span>

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">infiniteButts</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">yield</span> <span class="hljs-string">&apos;butts&apos;</span>;
    }
}

infiniteButts::map((x) =&gt; x.toUpperCase())::take(<span class="hljs-number">5</span>)::toArray();
<span class="hljs-comment">// =&gt; [&quot;BUTTS&quot;,&quot;BUTTS&quot;,&quot;BUTTS&quot;,&quot;BUTTS&quot;,&quot;BUTTS&quot;]</span>
</code></pre>
<p><code>map</code>, <code>take</code>, and <code>toArray</code> are all related functions and are used like methods, but they are not attached to any object --  they can be bound to anything that conforms to the <code>Symbol.iterator</code> protocol.</p>
<h1 id="interfaces-and-protocols">Interfaces and Protocols</h1>
<p>What if we used symbols and free methods to define some interfaces of our own?</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> GET_KEY = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-built_in">Object</span>.prototype[GET_KEY] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[key];
};
<span class="hljs-built_in">Map</span>.prototype[GET_KEY] = <span class="hljs-built_in">Map</span>.prototype.get;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[GET_KEY](key); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span> (<span class="hljs-params">key, otherwise</span>)</span>{
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>[GET_KEY](key);
    <span class="hljs-keyword">return</span> value !== <span class="hljs-literal">undefined</span> ? value : otherwise;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchIn</span> (<span class="hljs-params">path, otherwise</span>) </span>{
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> path) {
        <span class="hljs-keyword">if</span> (value &amp;&amp; value[GET_KEY]) {
            value = value[GET_KEY](key);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> otherwise;
        }
    }
    <span class="hljs-keyword">return</span> value;
}

<span class="hljs-keyword">let</span> foo = {
    bar: [
        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
            [<span class="hljs-string">&quot;baz&quot;</span>, {
                quux: <span class="hljs-string">&quot;you found it!&quot;</span>
            }]
        ])
    ]
};

foo::fetchIn([<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;baz&quot;</span>,<span class="hljs-string">&quot;quux&quot;</span>],<span class="hljs-string">&quot;oops&quot;</span>);
<span class="hljs-comment">// =&gt; &quot;you found it!&quot;</span>
foo::fetchIn([<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;baz&quot;</span>,<span class="hljs-string">&quot;quux&quot;</span>],<span class="hljs-string">&quot;oops&quot;</span>);
<span class="hljs-comment">// =&gt; &quot;oops&quot;</span>
</code></pre>
<p>This isn&apos;t yet a widespread pattern -- <a href="https://github.com/cognitect-labs/transducers-js/issues/20" target="_blank">transducers-js is experimenting with it</a> but I haven&apos;t been able to find many other examples of this in the wild. </p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        
        <a href="./docs/iterator.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Iterator"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
